---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Marc.
--- DateTime: 07/04/2021 11:29
---
local MAJOR, MINOR         = "LoggingLib-0.1", 1
local LoggingLib, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not LoggingLib then return end

LoggingLib.embeds     = LoggingLib.embeds or {}
LoggingLib.Colorama   = nil --LibStub("Colorama")
LoggingLib.AceConsole = LibStub("AceConsole-3.0")
LoggingLib.DLAPI      = DLAPI

if not LoggingLib.DLAPI and not LoggingLib.AceConsole then
    print("No logging facility ??? no DPLAPI, no AceConsole ... Aborting LoggingLib init")
    return
end

-- WoW APIs
local _G                           = _G
local format                       = format
--local Print                        = Print

LoggingLib.STARTUP                 = -1
LoggingLib.ERROR                   = 0
LoggingLib.WARNING                 = 1
LoggingLib.INFO                    = 2
LoggingLib.DEBUG                   = 3
LoggingLib.TRACE                   = 4

LoggingLib.UNDEFINED_CATEGORY      = "UNDEFINED"

LoggingLib.logging_level_to_string = {
    [LoggingLib.STARTUP] = "STARTUP",
    [LoggingLib.ERROR]   = "ERROR",
    [LoggingLib.WARNING] = "WARNING",
    [LoggingLib.INFO]    = "INFO",
    [LoggingLib.DEBUG]   = "DEBUG",
    [LoggingLib.TRACE]   = "TRACE",
}

LoggingLib.logging_string_to_level = {
    ["STARTUP"] = LoggingLib.STARTUP,
    ["ERROR"]   = LoggingLib.ERROR,
    ["WARNING"] = LoggingLib.WARNING,
    ["INFO"]    = LoggingLib.INFO,
    ["DEBUG"]   = LoggingLib.DEBUG,
    ["TRACE"]   = LoggingLib.TRACE,
}

if not LoggingLib.Colorama then
    LoggingLib.Default_Color_Map = {
        [LoggingLib.STARTUP] = '|cff00ccff',
        [LoggingLib.ERROR]   = '|cffff0000',
        [LoggingLib.WARNING] = '|cffFF4500',
        [LoggingLib.INFO]    = '|cff00ccff',
        [LoggingLib.DEBUG]   = '|cff7f7f7f',
        [LoggingLib.TRACE]   = '|cffADFF2F',
        ["STARTUP"]          = '|cff00ccff',
        ["ERROR"]            = '|cffff0000',
        ["WARNING"]          = '|cffFF4500',
        ["INFO"]             = '|cff00ccff',
        ["DEBUG"]            = '|cff7f7f7f',
        ["TRACE"]            = '|cffADFF2F',
    }
else
    print("Got Colorama lib - TODO: get data into it")
    LoggingLib.Default_Color_Map = {
        [LoggingLib.STARTUP] = '|cff00ccff',
        [LoggingLib.ERROR]   = '|cffff0000',
        [LoggingLib.WARNING] = '|cffFF4500',
        [LoggingLib.INFO]    = '|cff00ccff',
        [LoggingLib.DEBUG]   = '|cff7f7f7f',
        [LoggingLib.TRACE]   = '|cffADFF2F',
        ["STARTUP"]          = '|cff00ccff',
        ["ERROR"]            = '|cffff0000',
        ["WARNING"]          = '|cffFF4500',
        ["INFO"]             = '|cff00ccff',
        ["DEBUG"]            = '|cff7f7f7f',
        ["TRACE"]            = '|cffADFF2F',
    }
end

-- functions provided to using addon
local mixins = {
    "InitializeLogging",
    "IsLogLevelActive",
    "Trace",
    "Tracef",
    "Debug",
    "Debugf",
    "Info",
    "Infof",
    "Warning",
    "Warningf",
    "Error",
    "Errorf",
}

local DEFAULT_CATEGORY = "DEFAULT"

function LoggingLib:Embed(target)
    for k, v in pairs(mixins) do
        target[v] = self[v]
    end
    self.embeds[target] = true
    return target
end

function LoggingLib:InitializeLogging(addonName,
                                      level_colors,
                                      categories,
                                      active_level)
    self.addonName    = tostring(addonName)
    self.active_level = LoggingLib.TRACE

    -- Check categories
    if categories ~= nil and type(categories) ~= "table" then
        print(format("Categories should be a <string; color string (|c...)> map. Got type: %s",
                     type(categories)))
        return
    end

    self.categories_to_colors                                = categories
    self.categories_to_colors[LoggingLib.UNDEFINED_CATEGORY] = "|r"

    self.level_colors                                        = {}

    -- Check level_colors
    if level_colors and type(level_colors) == "table" then

        local str_level
        for l in { LoggingLib.ERROR, LoggingLib.WARNING, LoggingLib.INFO, LoggingLib.DEBUG, LoggingLib.TRACE, LoggingLib.STARTUP } do
            str_level = LoggingLib.logging_level_to_string[l]
            if not level_colors[l] and not level_colors[str_level] then
                print(format("Missing color level: %s. Aborting", str_level))
                return
            else
                self.level_colors[l]         = level_colors[l] or level_colors[str_level]
                self.level_colors[str_level] = level_colors[l] or level_colors[str_level]
            end
        end
    else
        -- print("Using default level colors")
        self.level_colors = LoggingLib.Default_Color_Map
    end
    -- Check active_level
    if type(active_level) == "number" then
        self.active_level = active_level
    elseif type(active_level) == "string" then
        self.active_level = LoggingLib.logging_string_to_level[active_level]
    else
        self.active_level = "TACHATTE"
        print(format("Invalid type for logging level: %s", type(self.active_level)))
        return
    end
end

function LoggingLib:IsLogLevelActive(level)
    local rval = self.active_level >= level
    return rval
end

function LoggingLib:GetLogLevelColor(level)
    return self.level_colors[level] or "|r"
end

function LoggingLib:GetLogLevelString(level)
    if type(level) == "string" then
        return level
    end
    return LoggingLib.logging_level_to_string[level] or "WTF"
end

local function LogMessage(self, cat, level, msg, ...)
    local levelStr  = LoggingLib.GetLogLevelString(self, level)
    local levelClr  = LoggingLib.GetLogLevelColor(self, level)
    levelStr = format("%s%s|r", levelClr, levelStr)
    --local msg_color = levelClr -- "|cff00b3ff"
    local msg_color = "|cff00b3ff"
    local msg_str = format("%s%s|r", msg_color, msg)
    if not cat then cat = LoggingLib.UNDEFINED_CATEGORY end
    local catStr = format("%s%s|r", tostring(self.categories_to_colors[cat]), tostring(cat))
    local new_f
    if LoggingLib.DLAPI then
        --new_f = format("%s%s~%d~%s%s: %s",
        --               levelClr, catStr,
        --               level,
        --               msg_color, levelStr,
        --               msg)
        new_f = format("%s~%d~%s: %s",
                       catStr, -- color + cat text  + reset
                       level,  -- number
                       levelStr,
                       msg_str)
        LoggingLib.DLAPI.DebugLog(self.addonName, new_f, ...)
    elseif LoggingLib.AceConsole then
        --LoggingLib.AceConsole.Printf(self, "%s%s %s%s", levelClr, levelStr, msg_color, msg, ...)
        LoggingLib.AceConsole.Printf(self, "%s %s", levelStr, msg_str, ...)
    else
        --
    end
end

local function LogMessagef(self, cat, level, f, ...)
    local levelStr  = LoggingLib.GetLogLevelString(self, level)
    local levelClr  = LoggingLib.GetLogLevelColor(self, level)
    levelStr = format("%s%s|r", levelClr, levelStr)
    --local msg_color = levelClr -- "|cff00b3ff"
    local msg_color = "|cff00b3ff"
    if not cat then cat = LoggingLib.UNDEFINED_CATEGORY end
    local catStr = format("%s%s|r", tostring(self.categories_to_colors[cat]), tostring(cat))
    local new_f
    if LoggingLib.DLAPI then
        --new_f = format("%s%s~%d~%s%s: %s", levelClr, catStr, level, msg_color, levelStr, f)
        new_f = format("%s~%d~%s: %s%s|r",
                       catStr, -- color + cat text  + reset
                       level,  -- number
                       levelStr,
                       msg_color,
                       f)
        new_f = format(new_f, ...)
        LoggingLib.DLAPI.DebugLog(self.addonName, new_f)
    elseif LoggingLib.AceConsole then
        --new_f = format("%s%s %s%s", levelClr, levelStr, msg_color, f)
        new_f = format("%s %s%s", levelStr, msg_color, f)
        --LoggingLib.AceConsole.Printf(self, new_f, ...)
    else
        --
    end
end

function LoggingLib:Trace(cat, msg)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.TRACE) then
        LogMessage(self, cat, LoggingLib.TRACE, msg)
    end
end

function LoggingLib:Tracef(cat, f, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.TRACE) then
        LogMessagef(self, cat, LoggingLib.TRACE, f, ...)
    end
end

function LoggingLib:Debug(cat, msg, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.DEBUG) then
        LogMessage(self, cat, LoggingLib.DEBUG, msg)
    end
end

function LoggingLib:Debugf(cat, f, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.DEBUG) then
        LogMessagef(self, cat, LoggingLib.DEBUG, f, ...)
    end
end

function LoggingLib:Info(cat, msg, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.INFO) then
        LogMessage(self, cat, LoggingLib.INFO, msg)
    end
end

function LoggingLib:Infof(cat, f, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.INFO) then
        LogMessagef(self, cat, LoggingLib.INFO, f, ...)
    end
end

function LoggingLib:Warning(cat, msg, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.WARNING) then
        LogMessage(self, cat, LoggingLib.WARNING, msg)
    end
end

function LoggingLib:Warningf(cat, f, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.WARNING) then
        LogMessagef(self, cat, LoggingLib.WARNING, f, ...)
    end
end

function LoggingLib:Error(cat, msg, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.ERROR) then
        LogMessage(self, cat, LoggingLib.ERROR, msg)
    end
end

function LoggingLib:Errorf(cat, f, ...)
    if LoggingLib.IsLogLevelActive(self, LoggingLib.ERROR) then
        LogMessagef(self, cat, LoggingLib.ERROR, f, ...)
    end
end